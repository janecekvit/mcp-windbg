name: Build and Release

on:
  push:
    tags:
      - 'v*.*.*'
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  DOTNET_VERSION: '8.0.x'
  BUILD_CONFIGURATION: 'Release'

jobs:
  build:
    runs-on: windows-latest
    permissions:
      contents: read
      checks: write

    outputs:
      version: ${{ steps.version.outputs.version }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Get version from tag or branch
      id: version
      shell: pwsh
      run: |
        if ($env:GITHUB_REF -match 'refs/tags/v(.+)') {
          $version = $matches[1]
          echo "version=$version" >> $env:GITHUB_OUTPUT
          echo "Version from tag: $version"
        } else {
          $shortSha = $env:GITHUB_SHA.Substring(0, 7)
          $version = "1.0.0-dev-$shortSha"
          echo "version=$version" >> $env:GITHUB_OUTPUT
          echo "Version from commit: $version"
        }

    - name: Restore dependencies
      run: dotnet restore DumpAnalyzer.sln

    - name: Build solution  
      run: dotnet build DumpAnalyzer.sln --no-restore --configuration ${{ env.BUILD_CONFIGURATION }}

    - name: Run tests
      run: |
        Write-Host "üß™ Running .NET tests..." -ForegroundColor Cyan

        try {
          dotnet test DumpAnalyzer.sln `
            --no-build `
            --configuration ${{ env.BUILD_CONFIGURATION }} `
            --verbosity normal `
            --logger trx `
            --logger "console;verbosity=detailed" `
            --results-directory TestResults `
            --collect:"XPlat Code Coverage" `
            -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura

          if ($LASTEXITCODE -eq 0) {
            Write-Host "‚úÖ All tests passed!" -ForegroundColor Green
          } else {
            Write-Host "‚ùå Some tests failed!" -ForegroundColor Red
            exit $LASTEXITCODE
          }
        }
        catch {
          Write-Host "‚ùå Test execution failed: $($_.Exception.Message)" -ForegroundColor Red
          throw
        }
      shell: pwsh

    - name: Generate test summary
      if: always()
      shell: pwsh
      run: |
        Write-Host "üìä Generating test summary..." -ForegroundColor Cyan

        # Count test results from TRX files
        $trxFiles = Get-ChildItem -Path "TestResults" -Filter "*.trx" -ErrorAction SilentlyContinue
        $totalTests = 0
        $passedTests = 0
        $failedTests = 0
        $skippedTests = 0

        foreach ($trxFile in $trxFiles) {
          try {
            [xml]$trx = Get-Content $trxFile.FullName
            $counters = $trx.TestRun.ResultSummary.Counters
            if ($counters) {
              $totalTests += [int]$counters.total
              $passedTests += [int]$counters.passed
              $failedTests += [int]$counters.failed
              $skippedTests += [int]$counters.inconclusive + [int]$counters.notExecuted + [int]$counters.notRunnable
            }
          }
          catch {
            Write-Warning "Could not parse $($trxFile.Name): $($_.Exception.Message)"
          }
        }

        # Generate summary
        Write-Host "üéØ Test Summary:" -ForegroundColor Yellow
        Write-Host "  Total: $totalTests" -ForegroundColor White
        Write-Host "  ‚úÖ Passed: $passedTests" -ForegroundColor Green
        Write-Host "  ‚ùå Failed: $failedTests" -ForegroundColor Red
        Write-Host "  ‚è≠Ô∏è Skipped: $skippedTests" -ForegroundColor Yellow

        # Set outputs for workflow summary
        echo "total-tests=$totalTests" >> $env:GITHUB_OUTPUT
        echo "passed-tests=$passedTests" >> $env:GITHUB_OUTPUT
        echo "failed-tests=$failedTests" >> $env:GITHUB_OUTPUT
        echo "skipped-tests=$skippedTests" >> $env:GITHUB_OUTPUT

        # Create workflow summary
        echo "## üß™ Test Results" >> $env:GITHUB_STEP_SUMMARY
        echo "| Metric | Count |" >> $env:GITHUB_STEP_SUMMARY
        echo "|--------|-------|" >> $env:GITHUB_STEP_SUMMARY
        echo "| Total | $totalTests |" >> $env:GITHUB_STEP_SUMMARY
        echo "| ‚úÖ Passed | $passedTests |" >> $env:GITHUB_STEP_SUMMARY
        echo "| ‚ùå Failed | $failedTests |" >> $env:GITHUB_STEP_SUMMARY
        echo "| ‚è≠Ô∏è Skipped | $skippedTests |" >> $env:GITHUB_STEP_SUMMARY

        if ($failedTests -gt 0) {
          echo "‚ùå **$failedTests test(s) failed!**" >> $env:GITHUB_STEP_SUMMARY
        } else {
          echo "‚úÖ **All tests passed!**" >> $env:GITHUB_STEP_SUMMARY
        }

    - name: Publish McpProxy
      run: |
        dotnet publish McpProxy/McpProxy.csproj `
          --configuration ${{ env.BUILD_CONFIGURATION }} `
          --runtime win-x64 `
          --output publish/win-x64 `
          --self-contained true `
          -p:PublishSingleFile=true `
          -p:PublishTrimmed=false `
          -p:PublishReadyToRun=false `
          -p:Version=${{ steps.version.outputs.version }}

    - name: Publish BackgroundService
      run: |
        dotnet publish BackgroundService/BackgroundService.csproj `
          --configuration ${{ env.BUILD_CONFIGURATION }} `
          --runtime win-x64 `
          --output publish/win-x64 `
          --self-contained true `
          -p:PublishSingleFile=true `
          -p:PublishTrimmed=false `
          -p:PublishReadyToRun=false `
          -p:Version=${{ steps.version.outputs.version }}

    - name: Create portable package
      shell: pwsh
      run: |
        $version = "${{ steps.version.outputs.version }}"
        
        Write-Host "üì¶ Creating WinDbg MCP Server package v$version"
        
        # Create package directory
        New-Item -ItemType Directory -Path "package" -Force
        
        # Copy executables (with validation)
        if (Test-Path "publish/win-x64/*.exe") {
          Copy-Item "publish/win-x64/*.exe" "package/" -Force
          Write-Host "‚úÖ Copied executables"
        } else {
          Write-Error "‚ùå No executables found in publish/win-x64/"
          exit 1
        }
        Copy-Item "publish/win-x64/*.pdb" "package/" -Force -ErrorAction SilentlyContinue
        
        # Copy scripts
        if (Test-Path "Scripts/") {
          Copy-Item "Scripts/" "package/Scripts/" -Recurse -Force
          Write-Host "‚úÖ Copied Scripts folder"
        }
        
        # Copy documentation
        Copy-Item "README.md" "package/" -Force -ErrorAction Stop
        Copy-Item "LICENSE" "package/" -Force -ErrorAction SilentlyContinue
        Copy-Item "CLAUDE.md" "package/" -Force -ErrorAction Stop
        
        # Copy configuration examples  
        Copy-Item "claude-mcp-config.json" "package/" -Force -ErrorAction Stop
        if (Test-Path "Tests/") {
          Copy-Item "Tests/" "package/Examples/" -Recurse -Force
          Write-Host "‚úÖ Copied Tests as Examples"
        }
        
        # Create version info file
        $versionContent = @"
        WinDbg MCP Server v$version
        Built on: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
        Commit: $env:GITHUB_SHA
        
        Files included:
        - McpProxy.exe (Main MCP server executable)
        - BackgroundService.exe (Background processing service)
        - Scripts/ (PowerShell scripts for standalone usage)
        - README.md (Complete documentation)
        - CLAUDE.md (Claude Code integration instructions)
        - claude-mcp-config.json (Configuration example)
        - Examples/ (Usage examples)
        
        Quick start:
        1. Run McpProxy.exe to start the MCP server
        2. Configure Claude Code with claude-mcp-config.json
        3. Use Scripts/cdb.ps1 for standalone dump analysis
        
        For detailed instructions, see README.md
        "@
        $versionContent | Out-File -FilePath "package/VERSION.txt" -Encoding UTF8
        
        # Create ZIP package
        $packageName = "windbg-mcp-server-v$version-win-x64"
        Compress-Archive -Path "package/*" -DestinationPath "$packageName.zip" -Force
        
        Write-Host "‚úÖ Created package: $packageName.zip"
        echo "package-name=$packageName" >> $env:GITHUB_OUTPUT
        echo "package-path=$packageName.zip" >> $env:GITHUB_OUTPUT
        
        # List package contents for verification
        Write-Host "üì¶ Package contents:"
        Get-ChildItem "package/" -Recurse | ForEach-Object { 
          $relativePath = $_.FullName.Replace((Resolve-Path "package/").Path, "")
          Write-Host "  $relativePath"
        }
        
        # Validate required files exist
        $requiredFiles = @("McpProxy.exe", "BackgroundService.exe", "README.md", "CLAUDE.md")
        foreach ($file in $requiredFiles) {
          if (Test-Path "package/$file") {
            Write-Host "‚úÖ Found required file: $file"
          } else {
            Write-Error "‚ùå Missing required file: $file"
            exit 1
          }
        }

    - name: Publish test results
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: .NET Tests
        path: TestResults/*.trx
        reporter: dotnet-trx
        fail-on-error: true

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-${{ steps.version.outputs.version }}
        path: TestResults/
        retention-days: 30

    - name: Upload code coverage
      uses: codecov/codecov-action@v4
      if: always()
      with:
        directory: TestResults
        fail_ci_if_error: false
        verbose: true
      env:
        CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: windbg-mcp-server-${{ steps.version.outputs.version }}
        path: |
          *.zip
          package/

  release:
    needs: build
    runs-on: windows-latest
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
      actions: read
    
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: windbg-mcp-server-${{ needs.build.outputs.version }}

    - name: Create Release Body
      id: release_body
      shell: pwsh
      run: |
        $body = @"
        ## WinDbg MCP Server ${{ needs.build.outputs.version }}
        
        Windows memory dump analysis tool with MCP (Model Context Protocol) integration.
        
        ### Features
        - Interactive debugging with persistent WinDbg/CDB sessions
        - 10 types of predefined analyses (basic, exception, threads, heap, etc.)
        - Claude Code integration via MCP protocol
        - Visual Studio Code and GitHub Copilot integration
        - Automatic debugger detection (Windows SDK, WinDbg Store App)
        - Single-file executable deployment
        
        ### What's included
        - ``McpProxy.exe`` - Main MCP server executable
        - ``BackgroundService.exe`` - Background processing service  
        - ``Scripts/`` - PowerShell scripts for standalone usage
        - ``README.md`` - Complete documentation and integration guide
        - ``claude-mcp-config.json`` - Configuration example for Claude Code
        - ``Examples/`` - Usage examples and test files
        
        ### Quick Start
        1. Download and extract the ZIP file
        2. Run ``McpProxy.exe`` to start the MCP server
        3. Configure Claude Code using the provided config example
        4. See ``README.md`` for detailed integration instructions
        
        ### Requirements
        - Windows 10/11
        - .NET 8.0 runtime (included in single-file executable)
        - Windows SDK Debuggers (cdb.exe) or WinDbg from Microsoft Store
        
        For detailed documentation, see [README.md](https://github.com/${{ github.repository }}/blob/${{ github.ref_name }}/README.md).
        "@
        echo "body<<EOF" >> $env:GITHUB_OUTPUT
        echo $body >> $env:GITHUB_OUTPUT
        echo "EOF" >> $env:GITHUB_OUTPUT

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        name: WinDbg MCP Server ${{ needs.build.outputs.version }}
        tag_name: ${{ github.ref_name }}
        body: ${{ steps.release_body.outputs.body }}
        draft: false
        prerelease: ${{ contains(github.ref_name, '-') }}
        files: "*.zip"
        token: ${{ secrets.GITHUB_TOKEN }}